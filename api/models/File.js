const { logger } = require('@librechat/data-schemas');
const { EToolResources, FileContext } = require('librechat-data-provider');
const { File } = require('~/db/models');

// In-memory store for files
const fileStore = new Map();
const MAX_FILES = 1000;

// Cleanup old files every 10 minutes to prevent memory leaks
setInterval(() => {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
  for (const [id, file] of fileStore.entries()) {
    if (new Date(file.updatedAt) < oneHourAgo) {
      fileStore.delete(id);
    }
  }

  if (fileStore.size > MAX_FILES) {
    const sorted = Array.from(fileStore.entries()).sort((a, b) => new Date(a[1].updatedAt) - new Date(b[1].updatedAt));
    const toDelete = sorted.slice(0, fileStore.size - MAX_FILES);
    for (const [id] of toDelete) {
      fileStore.delete(id);
    }
  }
}, 10 * 60 * 1000);

/**
 * Finds a file by its file_id with additional query options.
 * @param {string} file_id - The unique identifier of the file.
 * @param {object} options - Query options for filtering, projection, etc.
 * @returns {Promise<MongoFile>} A promise that resolves to the file document or null.
 */
const findFileById = async (file_id) => {
  return fileStore.get(file_id);
};

/**
 * Retrieves files matching a given filter, sorted by the most recently updated.
 * @param {Object} filter - The filter criteria to apply.
 * @param {Object} [_sortOptions] - Optional sort parameters.
 * @returns {Promise<Array<MongoFile>>} A promise that resolves to an array of file documents.
 */
const getFiles = async (filter) => {
  const files = Array.from(fileStore.values()).filter((file) => {
    for (const key in filter) {
      const filterVal = filter[key];
      const fileVal = file[key];

      if (typeof filterVal === 'object' && filterVal !== null) {
         if (filterVal.$in && Array.isArray(filterVal.$in)) {
           if (!filterVal.$in.includes(fileVal)) return false;
           continue;
         }
         if (filterVal.$ne !== undefined && fileVal === filterVal.$ne) return false;
         if (filterVal.$exists === true && fileVal === undefined) return false;
         if (filterVal.$exists === false && fileVal !== undefined) return false;
      } else if (fileVal !== filterVal) {
        return false;
      }
    }
    return true;
  });

  return files.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
};

/**
 * Retrieves tool files (files that are embedded or have a fileIdentifier) from an array of file IDs.
 * Note: execute_code files are handled separately by getCodeGeneratedFiles.
 * @param {string[]} fileIds - Array of file_id strings to search for
 * @param {Set<EToolResources>} toolResourceSet - Optional filter for tool resources
 * @returns {Promise<Array<MongoFile>>} Files that match the criteria
 */
const getToolFilesByIds = async (fileIds, toolResourceSet) => {
  if (!fileIds || !fileIds.length || !toolResourceSet?.size) {
    return [];
  }

  try {
    const orConditions = [];

    if (toolResourceSet.has(EToolResources.context)) {
      orConditions.push({ text: { $exists: true, $ne: null }, context: FileContext.agents });
    }
    if (toolResourceSet.has(EToolResources.file_search)) {
      orConditions.push({ embedded: true });
    }

    if (orConditions.length === 0) {
      return [];
    }

    const filter = {
      file_id: { $in: fileIds },
      context: { $ne: FileContext.execute_code }, // Exclude code-generated files
      $or: orConditions,
    };

    const selectFields = { text: 0 };
    const sortOptions = { updatedAt: -1 };

    return await getFiles(filter, sortOptions, selectFields);
  } catch (error) {
    logger.error('[getToolFilesByIds] Error retrieving tool files:', error);
    throw new Error('Error retrieving tool files');
  }
};

/**
 * Retrieves files generated by code execution for a given conversation.
 * These files are stored locally with fileIdentifier metadata for code env re-upload.
 * @param {string} conversationId - The conversation ID to search for
 * @param {string[]} [messageIds] - Optional array of messageIds to filter by (for linear thread filtering)
 * @returns {Promise<Array<MongoFile>>} Files generated by code execution in the conversation
 */
const getCodeGeneratedFiles = async (conversationId, messageIds) => {
  if (!conversationId) {
    return [];
  }

  /** messageIds are required for proper thread filtering of code-generated files */
  if (!messageIds || messageIds.length === 0) {
    return [];
  }

  try {
    const filter = {
      conversationId,
      context: FileContext.execute_code,
      messageId: { $exists: true, $in: messageIds },
      'metadata.fileIdentifier': { $exists: true },
    };

    const selectFields = { text: 0 };
    const sortOptions = { createdAt: 1 };

    return await getFiles(filter, sortOptions, selectFields);
  } catch (error) {
    logger.error('[getCodeGeneratedFiles] Error retrieving code generated files:', error);
    return [];
  }
};

/**
 * Retrieves user-uploaded execute_code files (not code-generated) by their file IDs.
 * These are files with fileIdentifier metadata but context is NOT execute_code (e.g., agents or message_attachment).
 * File IDs should be collected from message.files arrays in the current thread.
 * @param {string[]} fileIds - Array of file IDs to fetch (from message.files in the thread)
 * @returns {Promise<Array<MongoFile>>} User-uploaded execute_code files
 */
const getUserCodeFiles = async (fileIds) => {
  if (!fileIds || fileIds.length === 0) {
    return [];
  }

  try {
    const filter = {
      file_id: { $in: fileIds },
      context: { $ne: FileContext.execute_code },
      'metadata.fileIdentifier': { $exists: true },
    };

    const selectFields = { text: 0 };
    const sortOptions = { createdAt: 1 };

    return await getFiles(filter, sortOptions, selectFields);
  } catch (error) {
    logger.error('[getUserCodeFiles] Error retrieving user code files:', error);
    return [];
  }
};

/**
 * Creates a new file with a TTL of 1 hour.
 * @param {MongoFile} data - The file data to be created, must contain file_id.
 * @param {boolean} disableTTL - Whether to disable the TTL.
 * @returns {Promise<MongoFile>} A promise that resolves to the created file document.
 */
const createFile = async (data) => {
  const fileData = {
    ...data,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  fileStore.set(data.file_id, fileData);
  return fileData;
};

/**
 * Updates a file identified by file_id with new data and removes the TTL.
 * @param {MongoFile} data - The data to update, must contain file_id.
 * @returns {Promise<MongoFile>} A promise that resolves to the updated file document.
 */
const updateFile = async (data) => {
  const { file_id, ...update } = data;
  const existing = fileStore.get(file_id);
  if (!existing) return null;
  const updated = { ...existing, ...update, updatedAt: new Date() };
  fileStore.set(file_id, updated);
  return updated;
};

/**
 * Increments the usage of a file identified by file_id.
 * @param {MongoFile} data - The data to update, must contain file_id and the increment value for usage.
 * @returns {Promise<MongoFile>} A promise that resolves to the updated file document.
 */
const updateFileUsage = async (data) => {
  const { file_id, inc = 1 } = data;
  const existing = fileStore.get(file_id);
  if (!existing) return null;
  const updated = { ...existing, usage: (existing.usage || 0) + inc, updatedAt: new Date() };
  fileStore.set(file_id, updated);
  return updated;
};

/**
 * Deletes a file identified by file_id.
 * @param {string} file_id - The unique identifier of the file to delete.
 * @returns {Promise<MongoFile>} A promise that resolves to the deleted file document or null.
 */
const deleteFile = async (file_id) => {
  const file = fileStore.get(file_id);
  fileStore.delete(file_id);
  return file;
};

/**
 * Deletes a file identified by a filter.
 * @param {object} filter - The filter criteria to apply.
 * @returns {Promise<MongoFile>} A promise that resolves to the deleted file document or null.
 */
const deleteFileByFilter = async (filter) => {
  for (const [id, file] of fileStore.entries()) {
    let match = true;
    for (const key in filter) {
      if (file[key] !== filter[key]) {
        match = false;
        break;
      }
    }
    if (match) {
      fileStore.delete(id);
      return file;
    }
  }
  return null;
};

/**
 * Deletes multiple files identified by an array of file_ids.
 * @param {Array<string>} file_ids - The unique identifiers of the files to delete.
 * @returns {Promise<Object>} A promise that resolves to the result of the deletion operation.
 */
const deleteFiles = async (file_ids, user) => {
  let count = 0;
  if (user) {
    for (const [id, file] of fileStore.entries()) {
      if (file.user === user) {
        fileStore.delete(id);
        count++;
      }
    }
  } else if (file_ids && Array.isArray(file_ids)) {
    for (const id of file_ids) {
      if (fileStore.has(id)) {
        fileStore.delete(id);
        count++;
      }
    }
  }
  return { deletedCount: count };
};

/**
 * Batch updates files with new signed URLs in MongoDB
 *
 * @param {MongoFile[]} updates - Array of updates in the format { file_id, filepath }
 * @returns {Promise<void>}
 */
async function batchUpdateFiles(updates) {
  if (!updates || updates.length === 0) {
    return;
  }

  for (const update of updates) {
    const existing = fileStore.get(update.file_id);
    if (existing) {
      existing.filepath = update.filepath;
      existing.updatedAt = new Date();
      fileStore.set(update.file_id, existing);
    }
  }
}

module.exports = {
  findFileById,
  getFiles,
  getToolFilesByIds,
  getCodeGeneratedFiles,
  getUserCodeFiles,
  createFile,
  updateFile,
  updateFileUsage,
  deleteFile,
  deleteFiles,
  deleteFileByFilter,
  batchUpdateFiles,
};
