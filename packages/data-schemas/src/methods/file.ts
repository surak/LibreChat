import logger from '../config/winston';
import { EToolResources, FileContext } from 'librechat-data-provider';
import type { IMongoFile } from '~/types/file';

const fileStore = new Map<string, IMongoFile>();

// Factory function that returns the file methods
export function createFileMethods() {
  /**
   * Finds a file by its file_id.
   */
  async function findFileById(
    file_id: string,
    options: Record<string, unknown> = {},
  ): Promise<IMongoFile | null> {
    const file = fileStore.get(file_id);
    if (!file) return null;
    for (const key in options) {
      if ((file as any)[key] !== options[key]) return null;
    }
    return file;
  }

  /**
   * Retrieves files matching a given filter.
   */
  async function getFiles(
    filter: any,
    _sortOptions?: any,
    _selectFields?: any,
  ): Promise<IMongoFile[] | null> {
    const results = Array.from(fileStore.values()).filter(file => {
      for (const key in filter) {
        if (typeof filter[key] === 'object' && filter[key] !== null) {
           if (filter[key].$in && !filter[key].$in.includes((file as any)[key])) return false;
           if (filter[key].$ne && (file as any)[key] === filter[key].$ne) return false;
           if (filter[key].$exists === true && (file as any)[key] === undefined) return false;
           // Add more operators if needed
        } else if ((file as any)[key] !== filter[key]) {
          return false;
        }
      }
      return true;
    });

    results.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
    return results;
  }

  /**
   * Retrieves tool files.
   */
  async function getToolFilesByIds(
    fileIds: string[],
    toolResourceSet?: Set<EToolResources>,
  ): Promise<IMongoFile[]> {
    if (!fileIds || !fileIds.length || !toolResourceSet?.size) {
      return [];
    }

    try {
      const results = Array.from(fileStore.values()).filter(file => {
        if (!fileIds.includes(file.file_id)) return false;
        if (file.context === FileContext.execute_code) return false;

        if (toolResourceSet.has(EToolResources.context)) {
          if (file.text && file.context === FileContext.agents) return true;
        }
        if (toolResourceSet.has(EToolResources.file_search)) {
          if (file.embedded) return true;
        }
        return false;
      });

      results.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
      return results;
    } catch (error) {
      logger.error('[getToolFilesByIds] Error retrieving tool files:', error);
      throw new Error('Error retrieving tool files');
    }
  }

  /**
   * Retrieves files generated by code execution.
   */
  async function getCodeGeneratedFiles(
    conversationId: string,
    messageIds?: string[],
  ): Promise<IMongoFile[]> {
    if (!conversationId || !messageIds || messageIds.length === 0) {
      return [];
    }

    try {
      const filter = {
        conversationId,
        context: FileContext.execute_code,
        messageId: { $in: messageIds },
      };

      const results = await getFiles(filter);
      return (results || []).filter(f => f.metadata?.fileIdentifier);
    } catch (error) {
      logger.error('[getCodeGeneratedFiles] Error retrieving code generated files:', error);
      return [];
    }
  }

  /**
   * Retrieves user-uploaded execute_code files.
   */
  async function getUserCodeFiles(fileIds?: string[]): Promise<IMongoFile[]> {
    if (!fileIds || fileIds.length === 0) {
      return [];
    }

    try {
      const filter = {
        file_id: { $in: fileIds },
        context: { $ne: FileContext.execute_code },
      };

      const results = await getFiles(filter);
      return (results || []).filter(f => f.metadata?.fileIdentifier);
    } catch (error) {
      logger.error('[getUserCodeFiles] Error retrieving user code files:', error);
      return [];
    }
  }

  /**
   * Claim a file_id for a code-execution output.
   */
  async function claimCodeFile(data: {
    filename: string;
    conversationId: string;
    file_id: string;
    user: string;
  }): Promise<IMongoFile> {
    let existing = Array.from(fileStore.values()).find(f =>
      f.filename === data.filename &&
      f.conversationId === data.conversationId &&
      f.context === FileContext.execute_code
    );

    if (existing) return existing;

    const newFile: IMongoFile = {
      ...data,
      context: FileContext.execute_code,
      updatedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
    } as any;
    fileStore.set(data.file_id, newFile);
    return newFile;
  }

  /**
   * Creates a new file.
   */
  async function createFile(
    data: Partial<IMongoFile>,
    disableTTL?: boolean,
  ): Promise<IMongoFile | null> {
    const file_id = data.file_id as string;
    const existing = fileStore.get(file_id);
    const fileData: IMongoFile = {
      ...(existing || {}),
      ...data,
      expiresAt: disableTTL ? undefined : new Date(Date.now() + 3600 * 1000).toISOString(),
      updatedAt: new Date().toISOString(),
      createdAt: (existing as any)?.createdAt || new Date().toISOString(),
    } as any;

    fileStore.set(file_id, fileData);
    return fileData;
  }

  /**
   * Updates a file.
   */
  async function updateFile(
    data: Partial<IMongoFile> & { file_id: string },
  ): Promise<IMongoFile | null> {
    const { file_id, ...update } = data;
    const existing = fileStore.get(file_id);
    if (!existing) return null;
    const updated = { ...existing, ...update, updatedAt: new Date().toISOString() };
    delete (updated as any).expiresAt;
    fileStore.set(file_id, updated);
    return updated;
  }

  /**
   * Increments the usage of a file.
   */
  async function updateFileUsage(data: {
    file_id: string;
    inc?: number;
  }): Promise<IMongoFile | null> {
    const { file_id, inc = 1 } = data;
    const existing = fileStore.get(file_id);
    if (!existing) return null;
    const updated = {
      ...existing,
      usage: (existing.usage || 0) + inc,
      updatedAt: new Date().toISOString()
    };
    delete (updated as any).expiresAt;
    delete (updated as any).temp_file_id;
    fileStore.set(file_id, updated);
    return updated;
  }

  /**
   * Deletes a file.
   */
  async function deleteFile(file_id: string): Promise<IMongoFile | null> {
    const existing = fileStore.get(file_id);
    fileStore.delete(file_id);
    return existing || null;
  }

  /**
   * Deletes a file identified by a filter.
   */
  async function deleteFileByFilter(filter: any): Promise<IMongoFile | null> {
    for (const [id, file] of fileStore.entries()) {
      let match = true;
      for (const key in filter) {
        if ((file as any)[key] !== filter[key]) {
          match = false;
          break;
        }
      }
      if (match) {
        fileStore.delete(id);
        return file;
      }
    }
    return null;
  }

  /**
   * Deletes multiple files.
   */
  async function deleteFiles(
    file_ids: string[],
    user?: string,
  ): Promise<{ deletedCount?: number }> {
    let deletedCount = 0;
    if (user) {
       for (const [id, file] of fileStore.entries()) {
          if (file.user === user) {
             fileStore.delete(id);
             deletedCount++;
          }
       }
    } else {
       for (const id of file_ids) {
          if (fileStore.delete(id)) deletedCount++;
       }
    }
    return { deletedCount };
  }

  /**
   * Batch updates files.
   */
  async function batchUpdateFiles(
    updates: Array<{ file_id: string; filepath: string }>,
  ): Promise<void> {
    for (const update of updates) {
      const existing = fileStore.get(update.file_id);
      if (existing) {
        existing.filepath = update.filepath;
        existing.updatedAt = new Date().toISOString();
        fileStore.set(update.file_id, existing);
      }
    }
  }

  /**
   * Updates usage tracking for multiple files.
   */
  async function updateFilesUsage(
    files: Array<{ file_id: string }>,
    fileIds?: string[],
  ): Promise<IMongoFile[]> {
    const results: IMongoFile[] = [];
    const seen = new Set<string>();

    const process = async (fid: string) => {
      if (seen.has(fid)) return;
      seen.add(fid);
      const updated = await updateFileUsage({ file_id: fid });
      if (updated) results.push(updated);
    };

    for (const file of files) await process(file.file_id);
    if (fileIds) {
      for (const fid of fileIds) await process(fid);
    }

    return results;
  }

  return {
    findFileById,
    getFiles,
    getToolFilesByIds,
    getCodeGeneratedFiles,
    getUserCodeFiles,
    claimCodeFile,
    createFile,
    updateFile,
    updateFileUsage,
    deleteFile,
    deleteFiles,
    deleteFileByFilter,
    batchUpdateFiles,
    updateFilesUsage,
  };
}

export type FileMethods = ReturnType<typeof createFileMethods>;
